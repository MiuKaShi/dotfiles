# lf settings

# set shell bash
set shellopts '-eu'
set ifs "\n"
set scrolloff 10
set tabstop 2
set icons
set period 1
# set drawbox
set sortby natural
set ratios '1:2:3'
set timefmt '2006-01-02 15:04:05 -0700'
set errorfmt  "\033[31m%s\033[0m"
# set info size
set cleaner '~/.config/lf/cleaner'
set previewer '~/.config/lf/preview'
set autoquit true
# set smartcase
# set incsearch
# set dircounts

# ========
# = maps
# ========

# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Remove >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map t
map m
map n
map "'"
map '"'
map d
map c
map e
map y
map r
map f
map v
map p
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Basic >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map <esc> :quit
map v :toggle; down
map . set hidden!
map DD delete
map x cut
map <enter> open
map bg $setbg $f
map K top
map J bottom
map R reload
map U unselect
map O &handlr open $f
map = chmod+rx
map - chmod-x
map ch chmod
map cf chmodf
map cd chmodd
map zp nopreview
map g? $lf -doc | less
map <c-c> cmd-interrupt
map pp paste
map pt $xclip-pastefile
map pl paste_link
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Make >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map af push :touch<space>
map mf mkfile
map md mkdir
map mr sudomkfile
map ms $mkscript
map M moveto
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Open >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

map ee $$EDITOR "$f"
map es $sudo $EDITOR "$f"
map cz $$EDITOR ~/.config/zsh/.zshrc
map cn $$EDITOR ~/.config/nvim/plugin/general.lua
map cl $$EDITOR ~/.config/lf/lfrc
map cj caj
map C copyto
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Dragon >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map dr dragon
map ds dragon-stay
map di dragon-individual
map dm mvdragon
map dc cpdragon
map dl dlfile
map dd $trash -rf $fx
map <delete> delete
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Search >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map n search-next
map N search-prev
map fi filter
map zl push :z-jump<space>
map <c-f> :fzf_jump
# }}} >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> extract & zip >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map tz zip
map tt tar
map tg tgz
map tu extract
map tl sendf
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Quick Preview <<<<<<<<<<<<<<<<<<<<<<<<<<
map i $LESS='-iWQMXR~' bat --paging=always --theme=TwoDark "$f"
map I $$PAGER "$f"
# {{{ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Sort <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
map sn :{{ set sortby natural; set info size; set preview; set ratios 1:2:3; }}
map sa :{{ set sortby natural; set info size; set nopreview; set ratios 3:5; }}
map ss :{{ set sortby size; set info size; set preview; }}
map st :{{ set sortby time; set info time; set preview; }}
# }}} >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Copy >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map yy copy
map yb yank-bibtex
map yc yank-citeinfo
map yd yank-dirname
map yp yank-path
map yn yank-basename
map yN yank-basename-without-extension
map gf $lf -remote "send $id select $(fzf)"
map rr rename
map rp renamepaper
map rb  $printf '%s\n' $fx | vidir -
map rbb batch_rename
map zz zoteradd
map W $setsid -f $TERMINAL >/dev/null 2>&1

# ========
# = functions
# ========

# Command definitions {{{
# the prefix shows what kind of command it is
#   $: runs as shell command
#   %: runs as piped shell command (stdout => statusline)
#   !: runs as interactive shell command (puts lf in the bg)
#   :: runs as lf command
#
# commands run in the shell, you can use $f, $fs, $fx vars.
# you can also send remote commands.

cmd on-cd &{{
    if b=$(git branch --show-current) && [[ -n $b ]]; then
        lf -remote 'send '$id' set promptfmt "\033[2m%d at \033[33m'$b'"'
    elif [[ $lf_promptfmt == *' at '* ]]; then
        lf -remote 'send '$id' set promptfmt "\033[2m%d"'
    fi
}}
on-cd

cmd renamepaper $pdfrenamer "$f" >> /dev/null 2>&1

# paste as a symbolic link to original
cmd paste_link %{{
    for file in $(lf -remote 'load'); do
        if [ ! -n "${mode+1}" ]; then
            mode="$file"
            continue
        fi
        files+=("$file")
    done
    if [ -z "$files" ] || [ "${#files[@]}" -lt 1 ]; then
        lf -remote "send $id echo no files to link files: ${files}"
        exit 0
    fi
    ln -sr $files -t .
}}

cmd open ${{
    case $(file --mime-type "$(readlink -f $f)" -b) in
				application/vnd.openxmlformats-officedocument.spreadsheetml.sheet) et $fx ;;
				image/vnd.djvu|application/pdf|application/octet-stream|application/postscript) setsid -f sioyek $fx >/dev/null 2>&1 ;;
        text/*|application/json|inode/x-empty|application/x-subrip) $EDITOR $fx;;
        image/x-xcf) setsid -f gimp $f >/dev/null 2>&1 ;;
        image/svg+xml) display -- $f ;;
				image/*) rotdir $f | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|avif\|tif\|ico\)\(_large\)*$" |
					setsid -f nsxiv -aio 2>/dev/null | while read -r file; do
						[ -z "$file" ] && continue
						lf -remote "send select \"$file\""
						lf -remote "send toggle"
					done &
					;;
				audio/*|video/x-ms-asf) mpv --audio-display=no $f ;;
				video/*) setsid -f mpv $f -quiet >/dev/null 2>&1 ;;
				application/pdf|application/vnd.djvu) setsid -f sioyek $fx >/dev/null 2>&1 ;;
        application/epub*) setsid -f zathura $fx >/dev/null 2>&1 ;;
        application/pgp-encrypted) $EDITOR $fx ;;
        *) for f in $fx; do setsid -f $OPENER $f >/dev/null 2>&1; done;;
    esac
}}

cmd mkdir ${{
  printf "Directory Name: "
  read ans
  mkdir $ans
}}

cmd mkfile ${{
  printf "File Name: "
  read ans
  $EDITOR $ans
}}

cmd chmod ${{
  printf "Mode Bits: "
  read ans

  for file in "$fx"
  do
    chmod $ans $file
  done

  lf -remote 'send reload'
}}

cmd sudomkfile ${{
  printf "File Name: "
  read ans
  sudo $EDITOR $ans
}}

cmd caj ${{
    cajpdf $fx 
}}

cmd copyto ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Copy to where?"
	dest="$(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf | sed 's|~|$HOME|')" &&
	for x in $fx; do
		eval cp -ivr \"$x\" \"$dest\"
	done &&
	notify-send "ðŸ“‹ File(s) copied." "File(s) copies to $dest."
}}

cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.gz) gzip -dk $f;;
		*.tar.xz|*.txz) tar xJvf $f;;
        *.pkg.tar|*.tar) tar xvf $f;;
        *.tar.zst|*.zst) unzstd xJvf $f;;
        *.zip) unar $f;;
        *.rar) unrar x $f;;
        *.7z) 7z X $f;;
      *) echo "Unsupported format" ;;
    esac
}}

# zip a directory/file
cmd zip ${{
    set -f
    mkdir $f-zip
    cp -r $fx $f-zip
    (cd $f-zip/ && zip -9 -y -r -q $f.zip .)
    rm -rf $f-zip/
}}

cmd tar ${{
    set -f
    mkdir $f-tgz
    cp -r $fx $f-tgz
    (cd $f-tgz && tar cvzf $f.tar.gz .)
    rm -rf $f-tgz
}}

cmd tgz ${{
    set -f
    tar -cvf - $fx | pigz -k > $f.gz
}}

cmd sendf ${{
    sendfile $fx 
}}

map rf ${{
	dir="$(dirname "$fx")" 
	name="$(basename -a -- $fx | sed -e 's/ /_/g')"
	mv "$fx" "$dir/$name" 
}}

# Edit filename before the extension
map re ${{
	# get 'basename' of the selection
	filename="${f##*/}"
	# quote it so we won't deal with quotes in the lf -remote command
	filename="$(printf '%q' "$filename")"
	filename="${filename// /<space>}"
	lf -remote "send $id push :rename<space>$filename<a-b><c-b>"
}}

cmd showpreview &{{
    lf -remote "send $id set preview"
    lf -remote "send $id set ratios 1:2:3"
    lf -remote "send $id map zp nopreview"
}}

cmd nopreview &{{
    lf -remote "send $id set nopreview"
    lf -remote "send $id ratios 1:3"
    lf -remote "send $id map zp showpreview"
}}

cmd zoteradd ${{
            zotadd "$f"

}}

# copy the path of the highlighted file
cmd copy_path ${{
    set -f
    if command -v pbcopy > /dev/null 2> /dev/null; then
        echo "$f" | tr -d '\n' | pbcopy
    elif command -v xclip > /dev/null 2> /dev/null; then
        echo "$f" | tr -d '\n' | xclip -sel clip
    fi
}}

# rename multiple files the way nnn does it
cmd batch_rename !{{
    contentsfile=$(mktemp)
    trap 'rm $contentsfile' INT TERM EXIT
    dircontents="$(command ls -1p)"
    printf "%s" "$dircontents" | nl -n ln > "$contentsfile";
    $EDITOR "$contentsfile"
    printf "%s" "$dircontents" | paste "$contentsfile" -d'\t' - \
        | while read -r line; do
        orig="$(printf "%s" "$line" | cut -f3 | sed 's!/$!!')"
        new="$(printf "%s" "$line" | cut -f2 | sed 's!/$!!')"
        if [ "$new" != "$orig" ]; then
            if [ -e "$new" ]; then
                printf "%s already exists, not overwriting.\n" "$new"
            else
                printf "./%s -> ./%s\n" "$orig" "$new"
                command mv -i ./"$orig" ./"$new"
            fi
        fi
    done
    rm "$contentsfile"
    trap - INT TERM EXIT
}}

cmd yank-bibtex $papers extract "$f" | xclip -sel clip
cmd yank-citeinfo $papers doi "$f" | xargs cite --style elsevier-vancouver | xclip -sel clip
cmd yank-dirname $dirname -- "$f" | head -n 1 | xclip -sel clip
cmd yank-path $printf '%s' "$fx" | xclip -sel clip
cmd yank-basename $printf '%s' "$(basename -a -- $fx)" |  xclip -sel clip
cmd yank-basename-without-extension ${{
    echo "$fx" |
      xargs -r -d '\n' basename -a |
      awk -e '{
      for (i=length($0); i > 0; i--) {
        if (substr($0, i, 1) == ".") {
          if (i == 1)
              print $0
          else
              print substr($0, 0, i-1)
          break
        }
      }

      if (i == 0)
        print $0
      }' |
      if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
      xclip -sel clip
}}

cmd dragon %dragon-drop -a -x $fx

cmd moveto ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Move to where?"
	dest="$(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf | sed 's|~|$HOME|')" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	notify-send "ðŸšš File(s) moved." "File(s) moved to $dest."
}}

cmd fzf_jump ${{
  res="$(find . -maxdepth 3 | fzf --reverse --header='Jump to location')"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}

map zc ${{
    filename="$(basename "${f##*/}" | sed 's/\(.*\)\..*/\1/' | sed 's/[ ][ ]*/_/g')"
    curl -X POST -H "Accept: application/x-bibtex" --form input=@"$f" --form consolidateCitations=2 https://kermitt2-grobid.hf.space/api/processReferences > $filename.bib
    bibtex2html $filename.bib
}}

cmd z-jump ${{
  z_exe="/usr/share/zsh/plugins/z.lua/z.lua"
  lf -remote "send ${id} cd '$($z_exe -I -e $1)'"
}}

# define a custom 'delete' command
cmd delete ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	printf "%s\n\t" "$fx"
	printf "delete?[y/N]"
	read ans
	[ $ans = "y" ] && rm -rf -- $fx
}}

# Run chmod on a file
cmd chmod+rx %{{
  chmod +rx $f
  lf -remote "send reload"
}}

cmd chmod-x %{{
  chmod -x $f
  lf -remote "send reload"
}}

cmd chmodf %{{
	find $fx -type f -print0 | xargs -0 chmod 0644
}}

cmd chmodd %{{
	find $fx -type d -print0 | xargs -0 chmod 0755
}}


# Select based on glob filter
cmd filter %{{
    printf "Filter: "
    read -r filter_expr
    lf -remote "send $id unselect"
    lf -remote "send $id glob-select $filter_expr"
}}

cmd touch %touch  "$@"
cmd dragon %dragon-drop -a -x $fx
cmd dragon-stay %dragon-drop -a $fx
cmd dragon-individual %dragon-drop $fx
cmd cpdragon %cpdragon
cmd mvdragon %mvdragon
cmd dlfile %dlfile

# }}} >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Bookmarks >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
source "~/.config/lf/shortcutrc"
