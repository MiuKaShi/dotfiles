#!/usr/bin/env python3

import os
import sys
import re
import time
import subprocess
import requests as rq
from bs4 import BeautifulSoup

base_url = "https://v2.doc2x.noedgeai.com"

api_file = os.path.expanduser("~/.api_keys/DOC2X_KEY")
if not os.path.isfile(api_file):
    # print(f"no {api_file} file，exit!")
    os.system('notify-send "Exit" "API key is not found!"')
    sys.exit(1)
with open(api_file, "r", encoding="utf-8") as f:
    secret = f.read().strip()


def preupload():
    url = f"{base_url}/api/v2/parse/preupload"
    headers = {"Authorization": f"Bearer {secret}"}
    res = rq.post(url, headers=headers)
    res.raise_for_status()  # Check if HTTP request is successful
    data = res.json()
    if data.get("code") == "success":
        return data["data"]
    raise Exception(f"get preupload url failed: {data}")


def put_file(path: str, url: str):
    with open(path, "rb") as f:
        res = rq.put(url, data=f)  # Body is binary file stream
        res.raise_for_status()  # Check if HTTP request is successful


def get_status(uid: str):
    url = f"{base_url}/api/v2/parse/status?uid={uid}"
    headers = {"Authorization": f"Bearer {secret}"}
    res = rq.get(url, headers=headers)
    res.raise_for_status()  # Check if HTTP request is successful
    data = res.json()
    if data.get("code") == "success":
        return data["data"]
    raise Exception(f"get status failed: {data}")


def open_with_editor(filepath):
    editor = os.environ.get("EDITOR", "vim")
    terminal = os.environ.get("$TERMINAL", "st")
    subprocess.Popen([terminal, "-e", editor, filepath])


def format_table(table):
    soup = BeautifulSoup(table, "html.parser")
    rows = soup.find_all("tr")
    table_data = []

    for row in rows:
        cells = row.find_all(["th", "td"])
        row_data = [cell.decode_contents().strip() for cell in cells]
        table_data.append(row_data)

    if not table_data:
        return ""

    # 自动补全缺失的列，使每行列数一致
    num_cols = max(len(row) for row in table_data)
    for row in table_data:
        if len(row) < num_cols:
            row.extend([""] * (num_cols - len(row)))

    col_widths = [max(len(row[i]) for row in table_data) for i in range(num_cols)]
    markdown_lines = []
    header = table_data[0]
    header_line = (
        "| "
        + " | ".join(header[i].ljust(col_widths[i]) for i in range(num_cols))
        + " |"
    )
    markdown_lines.append(header_line)
    divider_line = (
        "| " + " | ".join("-" * col_widths[i] for i in range(num_cols)) + " |"
    )
    markdown_lines.append(divider_line)

    # 数据行
    for row in table_data[1:]:
        row_line = (
            "| "
            + " | ".join(row[i].ljust(col_widths[i]) for i in range(num_cols))
            + " |"
        )
        markdown_lines.append(row_line)

    return "\n".join(markdown_lines)


def convert_tables(markdown_text):
    pattern = re.compile(r"<table>.*?</table>", re.DOTALL)

    def repl(match):
        table = match.group(0)
        return format_table(table)

    return pattern.sub(repl, markdown_text)


def main():
    if len(sys.argv) > 2:
        print("用法: python get_markdown.py <输入PDF文件>")
        sys.exit(1)

    # 输入 PDF 文件
    input_md_file = sys.argv[1]
    # 输出 MD 文件
    base, _ = os.path.splitext(input_md_file)
    output_md_file = base + "_txt.md"
    output_media_file = base + "_med.md"

    if os.path.isfile(output_md_file):
        open_with_editor(output_md_file)
        sys.exit(0)
    else:
        os.system('notify-send "PDF2MD" "processing..."')

    upload_data = preupload()
    # print(upload_data)
    url, uid = upload_data["url"], upload_data["uid"]

    put_file(input_md_file, url)

    max_retries = 100
    for retries in range(max_retries):
        status_data = get_status(uid)
        status = status_data.get("status")
        if status == "success":
            pages = status_data["result"]["pages"]
            # 收集所有 md 字段内容
            input_markdown = []
            for page in pages:
                if "md" in page:
                    input_markdown.append(page["md"])
            output_markdown = "".join(input_markdown)

            # Preprocess markdown content

            # format equation tag
            pattern = re.compile(r"\\tag\{(.*?)\}")
            replacement = r"\\qquad \\text{(\1)}"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # inline math \( \) to $
            pattern = re.compile(r"\\\(\s*(.*?)\s*\\\)")
            replacement = r"$\1$"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # inline math \mathrm{\;{****}} to ****
            pattern = re.compile(r"\\mathrm\{\s*\\;\{\s*(.*?)\s*\}\s*\}")
            replacement = r"\1"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # inline math \mathrm{****} to ****
            pattern = re.compile(r"\\mathrm\s*\{\s*(.*?)\s*\}")
            replacement = r"\1"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # block math \[ \] to $$
            pattern = re.compile(r"\\\[\s*(.*?)\s*\\\]", re.DOTALL)
            replacement = r"$$\n\1\n$$"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # replace $$$$ with $$\n$$ for better readability
            output_markdown = re.sub(r"\$\$\$\$", "$$\n$$", output_markdown)

            # format URL
            pattern = re.compile(r'<img\s+src\s*=\s*"([^"]+)"\s*/?>')
            replacement = r"![](\1)"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # format table
            pattern = re.compile(
                r"\\begin{center}\s*\\adjustbox{max width=\\textwidth}{\s*(.*?)\s*\\end{tabular}\s*}\s*\\end{center}",
                re.DOTALL,
            )
            replacement = r"\\begin{center}\n\1\n\\end{tabular}\n\\end{center}"
            output_markdown = re.sub(pattern, replacement, output_markdown)

            # Extract media blocks from output_markdown
            media_markdown = re.findall(
                r"<!-- Media -->(.*?)<!-- Media -->", output_markdown, flags=re.DOTALL
            )
            media_markdown = "".join(media_markdown)
            # tables to markdown tables
            media_markdown = convert_tables(media_markdown)

            # remove media blocks from output_markdown
            output_markdown = re.sub(
                r"(?s)<!-- Media -->.*?<!-- Media -->", "", output_markdown
            )

            # Remove footnote and blank blocks
            output_markdown = re.sub(
                r"(?s)<!-- Footnote -->.*?<!-- Footnote -->", "", output_markdown
            )
            output_markdown = re.sub(r"(?s)---.*?---", "", output_markdown)

            # remove \;
            output_markdown = re.sub(r"\\;", "", output_markdown)

            # format blank lines
            pattern = re.compile(r"(\n\s*){2,}")
            replacement = "\n\n"
            output_markdown = re.sub(pattern, replacement, output_markdown)
            media_markdown = re.sub(pattern, replacement, media_markdown)

            # 输出 MD 文件
            os.system('notify-send "PDF2MD" "finished!"')
            with open(output_md_file, "w", encoding="utf-8") as f:
                f.write(output_markdown)
            with open(output_media_file, "w", encoding="utf-8") as f:
                f.write(media_markdown)
            open_with_editor(output_md_file)
            return
        elif status == "failed":
            # print(status_data)
            os.system('notify-send "PDF2MD" "failed!"')
            raise Exception(f"parse failed: {status_data.get('detail')}")
        elif status == "processing":
            # print(status_data)
            # print(f"progress: {status_data.get('progress')}")
            os.system('notify-send "PDF2MD" "processing..."')
            time.sleep(3)
    raise Exception(f"Fails to deal with uid: {uid} after {max_retries} retries")


if __name__ == "__main__":
    main()
